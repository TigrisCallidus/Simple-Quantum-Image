// -*- coding: utf-8 -*-

// This code is part of Qiskit.
//
// (C) Copyright IBM 2020.
//
// This code is licensed under the Apache License, Version 2.0. You may
// obtain a copy of this license in the LICENSE.txt file in the root directory
// of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
//
// Any modifications or derivative works of this code must retain this
// copyright notice, and modified files need to carry a notice indicating
// that they have been altered from the originals.

using SimpleFileBrowser;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

public class TerrainGenerator : MonoBehaviour {

    [Tooltip("The texture which gets modified with the quantum effect. MUST HAVE READ/WRITE ENABLED! (Choose a small texture (256x256 at first)")]
    public Texture2D TextureToBlur;
    [Tooltip("Used in the blur effect, determines how strong the image gets chag")]
    public float BlurRotation = 0.25f;

    [Tooltip("The texture which gets made into a terrain. Gets generated by Blur effect, but can be set seperately (make sure to have read/write enabled and not to choose a too big texture)")]
    public Texture2D BlurredTexture;

    //[Tooltip("The texture which can be used to add transparency to the texture to blur")]
    //public Texture2D TextureForTransparency;

    [Tooltip("The texture which can be used to cut the terrain.")]
    public Texture2D TextureForCut;

    [Tooltip("Normally the lighter a pixel is the higher the terrain will be. This behaviour is inverted if checked.")]
    public bool Invert;
    [Tooltip("The maximal height the terrain will have.")]
    public int MaxHeight = 10;
    [Tooltip("The threshold used by the noise methods")]
    public float Threshold = 0.5f;
    [Tooltip("If this is ticked, the most bottom cube will be left away, which makes it possible for the image to have holes.")]
    public bool RemoveBottomRow = true;

    [Tooltip("The gradient used to color the terrain. (The mesh has vertex color set and uses a simple shader which uses them)")]
    public Gradient HeighGradient;

    //not needed at the moment
    [HideInInspector]
    [Tooltip("Offset used for the coloring. (between -1 and 1)")]
    public float ColorOffset = 0;
    [HideInInspector]
    [Tooltip("The scaling factor used for the coloring. Normally a point with maximal height has the color at point 1 in the gradient, this changes the behaviour.")]
    public float ColorScaling = 1;
    

    [Tooltip("Which Algorithm should be used in order to generate the mesh.")]
    public VisualitationType VisualisationMethod;
    [Tooltip("How should the mesh be colored?")]
    public MaterialType ColoringMethod;



    //Currently not needed

    [HideInInspector]
    [Tooltip("The name of the mesh, if it should be saved to a file.")]
    public string MeshName = "TestMesh";
    [HideInInspector]
    [Tooltip("The generated Mesh. Can be double clicked to inspect. (And accessed from other scripts)")]
    public Mesh GeneratedMesh;
    [HideInInspector]
    [Tooltip("The used profile for the settings above. Different profiles allow to easy save and switch profiles for different kinds of pictures.")]
    public MeshCreationSettings UsedProfile;

    [HideInInspector]
    [Tooltip("The name of the file to which settings are exported. Will be a json file directly in the assets folder. ")]
    public string JsonFileName = "ExportedSettings";


    //Linking only uncomment the HideInInspector if the link is somehow lost
    [HideInInspector]
    public MeshFilter TargetMesh;

    //No need to show in the editor, can be accessed from other scripts. 
    [HideInInspector]
    public DataGrid Data2D;
    [HideInInspector]
    public Data3D Data3D;

    [HideInInspector]
    public bool MixGradiants = false;
    [HideInInspector]
    public Gradient HeighGradient2;
    [HideInInspector]
    public float GradientMixvalue = 0;
    [HideInInspector]
    public LightningController Lightning;

    [HideInInspector]
    public Camera MainCamera;

    [HideInInspector]
    public bool showAdvanced;


    [HideInInspector]
    public bool prepareMerge;
    [HideInInspector]
    public LayerMask ObjectNumber;

    //Path to the generatedMeshes folder change if you move this plugin around
    const string path = "Assets/Visuals/GeneratedMeshes/";


    /// <summary>
    /// Applying simple QuantumBlur (the Unity implementation) to the TextureToBlur
    /// The new Image becomes the InputTexture (Which can also be set directly)
    /// </summary>
    public void ApplyBlur(bool clearData = true) {

        if (TextureToBlur == null) {
            Debug.LogError("No texture to blur specified!");
            return;
        }

        BlurredTexture = QuantumBlurUsage.CalculateUnityBlur(TextureToBlur, BlurRotation);
        if (clearData) {
            //Clearing data
            Data3D = null;
            Data2D = null;
        }
    }

    /// <summary>
    /// Applying your own effect (implemented in QuantumBlurUsages "CalculateMyOwnEffect" function) to your image
    /// </summary>
    public void ApplyYourOwnEffect(bool clearData = true) {

        if (TextureToBlur == null) {
            Debug.LogError("No texture to blur specified!");
            return;
        }

        BlurredTexture = QuantumBlurUsage.CalculateMyOwnEffect(TextureToBlur, BlurRotation);
        if (clearData) {
            //Clearing data
            Data3D = null;
            Data2D = null;
        }
    }

    /// <summary>
    /// Transforming the image into 2D Data. (An internal 2D float array).
    /// </summary>
    public void Generate2DData() {

        if (BlurredTexture == null) {
            Debug.LogWarning("No input texture specified, trying to blur texture");
            ApplyBlur(false);
            if (BlurredTexture == null) {
                return;
            }
        }

        int width = BlurredTexture.width;
        int height = BlurredTexture.height;

        Data2D = new DataGrid(width, height);

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                Color color = BlurredTexture.GetPixel(i, j);
                float luma = 0.2126f * color.r + 0.7152f * color.g + 0.0722f * color.b;
                if (Invert) {
                    luma = 1 - luma;
                }
                Data2D[i, j].Value = luma;
            }
        }
    }

    /// <summary>
    /// Transforming the 2D data in a 3D array according to height.
    /// This is needed for several methods using a cube grid to generate the landscape.
    /// </summary>
    public void Generate3DDataFrom2DData() {
        if (Data2D == null) {
            Generate2DData();
        }
        int width = BlurredTexture.width;
        int height = BlurredTexture.height;
        int vertical = MaxHeight + 1;


        float maxValue = 1.0f / MaxHeight;
        float currMax = 0;

        int startZ = 0;

        if (!RemoveBottomRow) {
            vertical = vertical + 1;
            Data3D = new Data3D(width, height, vertical);
            for (int x = 0; x < width; x++) {
                for (int y = 0; y < height; y++) {
                    for (int z = 0; z < 1; z++) {
                        Data3D[x, y, z].Value = 1;
                    }
                }
            }
            startZ = 1;
        } else {
            Data3D = new Data3D(width, height, vertical);
        }

        for (int z = startZ; z < vertical - 1; z++) {
            for (int x = 0; x < width; x++) {
                for (int y = 0; y < height; y++) {
                    if (!RemoveBottomRow && z == 1) {
                        Data3D[x, y, z].Value = 1;
                    } else {
                        Data3D[x, y, z].Value = Mathf.Clamp((Data2D[x, y].Value - currMax) * MaxHeight, 0, 1);
                    }
                }
            }
            currMax += maxValue;
        }
    }

    /*
    public void ApplyTransparency() {
        Texture2D blurCopy = new Texture2D(BlurredTexture.width,BlurredTexture.height);

        int blurWidth = TextureForTransparency.width;
        int blurHeight = TextureForTransparency.height;

        int originalWidth = BlurredTexture.width;
        int originalHeight = BlurredTexture.height;

        for (int i = 0; i < originalWidth; i++) {
            for (int j = 0; j < originalHeight; j++) {

                Color col = BlurredTexture.GetPixel(i, j);
                Color alpha = TextureForTransparency.GetPixel(i * blurWidth / originalWidth, j * blurHeight / originalHeight);

                blurCopy.SetPixel(i, j, new Color(col.r , col.g , col.b , alpha.a));

            }
        }
        blurCopy.Apply();
        BlurredTexture = blurCopy;
    }

    */

    public void ApplyCut() {
        Texture2D blurCopy = new Texture2D(BlurredTexture.width, BlurredTexture.height);

        int blurWidth = TextureForCut.width;
        int blurHeight = TextureForCut.height;

        int originalWidth = BlurredTexture.width;
        int originalHeight = BlurredTexture.height;

        for (int i = 0; i < originalWidth; i++) {
            for (int j = 0; j < originalHeight; j++) {

                Color col = BlurredTexture.GetPixel(i, j);
                Color cut = TextureForCut.GetPixel(i * blurWidth / originalWidth, j * blurHeight / originalHeight);

                blurCopy.SetPixel(i, j, new Color(col.r *cut.r, col.g * cut.r, col.b*cut.r, cut.r*cut.r));
            }
        }
        blurCopy.Apply();
        BlurredTexture = blurCopy;
    }

    /// <summary>
    /// Generating a mesh (terrain) representation of the chosen image, according to the selected visualisation method.
    /// </summary>
    public void GenerateMesh(bool setAdditionalValues = true, float maxheight = 0) {

        if (maxheight == 0) {
            maxheight = MaxHeight;
        }

        if (MixGradiants) {
            MixGradiants = false;
            Debug.Log("setting MixGradients to false");
        }

        if (VisualisationMethod == VisualitationType.Noise2D) {
            if (Data2D == null) {
                Generate2DData();
            }
        } else {
            if (Data3D == null) {
                Generate3DDataFrom2DData();
            }
        }

        switch (VisualisationMethod) {
            case VisualitationType.Noise2D:
                GeneratedMesh = Generate2DNoise(Data2D, Threshold);
                break;
            case VisualitationType.Noise3D:
                GeneratedMesh = Generate3DNoise(Data3D, Threshold, !RemoveBottomRow);
                break;
            case VisualitationType.Terrain:
                GeneratedMesh = GenerateTerrain(Data2D, maxheight, RemoveBottomRow);
                break;
            case VisualitationType.MarshingCubes:
                GeneratedMesh = GenerateMarshingCubes(Data3D, Threshold, maxheight, !RemoveBottomRow);
                break;
            case VisualitationType.MarshingCubesAdvanced:
                GeneratedMesh = GenerateMarshingCubesAdvanced(Data3D, Threshold, maxheight, !RemoveBottomRow);
                break;
            case VisualitationType.SmoothNoise3D:
                GeneratedMesh = Generate3DNoiseSmooth(Data3D, Threshold, !RemoveBottomRow);
                break;
            case VisualitationType.SmoothMarshingCubes:
                GeneratedMesh = GenerateMarshingCubesSmooth(Data3D, Threshold, maxheight, !RemoveBottomRow);
                break;
            case VisualitationType.SmoothMarshingCubesAdvanced:
                GeneratedMesh = GenerateMarshingCubesAdvancedSmooth(Data3D, Threshold, maxheight, !RemoveBottomRow);
                break;
            default:
                break;
        }

        if (setAdditionalValues) {
            ColorMesh();
        }

        if (TargetMesh != null) {
            TargetMesh.mesh = GeneratedMesh;

        } else {
            Debug.LogError("TargetMesh is null, need to be linked again");
        }
    }

    /// <summary>
    /// Using a method similar to visualising 2D (perlin) noise.
    /// Blocks are either there or not according to the brightness of the picture is over the threshold.
    /// </summary>
    /// <param name="data2D">the 2D data of the image</param>
    /// <param name="threshold">Value between 0 and 1. The "noise" threshold the lower it is the more blocks are visualised</param>
    /// <returns>A mesh representing the image.</returns>
    public static Mesh Generate2DNoise(DataGrid data2D, float threshold) {

        Vector3 StartPos = new Vector3(-0.5f * data2D.X + 0.5f, 0.5f, -0.5f * data2D.Y - 0.5f);
        Vector3 spawnPosition;


        List<Vector3> positions = new List<Vector3>();
        List<bool[]> ignoreFace = new List<bool[]>();
        for (int i = 0; i < data2D.X; i++) {
            for (int j = 0; j < data2D.Y; j++) {
                if (data2D[i, j].Value > threshold) {
                    spawnPosition = StartPos + new Vector3(i, 0, j);
                    positions.Add(spawnPosition);
                    bool[] ignore = new bool[6] {
                        j>0 && data2D[i,j-1].Value>threshold,
                        j<data2D.Y-1 && data2D[i,j+1].Value>threshold,
                        false,
                        i<data2D.X-1 && data2D[i+1,j].Value>threshold,
                        true,
                        i>0 && data2D[i-1,j].Value>threshold,

                    };
                    ignoreFace.Add(ignore);
                }
            }
        }
        return MeshGenerator.GetCubes(positions, ignoreFace, Vector3.one);
    }

    /// <summary>
    /// Generating a mesh interpreting the 3D data as noise and generating cubes in a 3D grid if the noise is over the threshold
    /// </summary>
    /// <param name="data3D">The 3D data representation of the image (or of anything else if you want).</param>
    /// <param name="threshold">Value between 0 and 1. A good value here is normally 0.5 Different values can be appropriate for different (non image) data.</param>
    /// <param name="alwaysDrawBottomCube">With this parameter set the lowest place of cubes is always drawn. Making sure there are no "holes"</param>
    /// <returns></returns>
    public static Mesh Generate3DNoise(Data3D data3D, float threshold, bool alwaysDrawBottomCube = true) {
        Vector3 StartPos = new Vector3(-0.5f * data3D.X + 0.5f, 0.5f, -0.5f * data3D.Y - 0.5f);
        if (alwaysDrawBottomCube) {
            StartPos = new Vector3(-0.5f * data3D.X + 0.5f, -0.5f, -0.5f * data3D.Y - 0.5f);
        }
        Vector3 spawnPosition;



        List<Vector3> positions = new List<Vector3>();
        List<bool[]> ignoreFace = new List<bool[]>();
        List<Vector2> uv = new List<Vector2>();

        float scaleX = 1.0f / data3D.X;
        float scaleY = 1.0f / data3D.Y;
        float scaleZ = 1.0f / data3D.Z;

        for (int i = 0; i < data3D.X; i++) {
            for (int j = 0; j < data3D.Y; j++) {
                for (int k = 0; k < data3D.Z; k++) {


                    if (data3D[i, j, k].Value > threshold) {
                        spawnPosition = StartPos + new Vector3(i, k, j);
                        positions.Add(spawnPosition);
                        bool[] ignore = new bool[6] {
                            j>0 && data3D[i,j-1,k].Value>threshold,
                            j<data3D.Y-1 && data3D[i,j+1,k].Value>threshold,
                            k<data3D.Z-1 && data3D[i,j,k+1].Value>threshold,
                            i<data3D.X-1 && data3D[i+1,j,k].Value>threshold,
                            (k==0) || data3D[i,j,k-1].Value>threshold,
                            i>0 && data3D[i-1,j,k].Value>threshold,

                        };

                        ignoreFace.Add(ignore);
                        int siteCount = 0;
                        for (int count2 = 0; count2 < 6; count2++) {
                            if (!ignore[count2]) {
                                siteCount++;
                            }
                        }
                        int endcount = siteCount * 4;
                        //Todo make option for flowing colors
                        for (int count = 0; count < endcount; count++) {
                            Vector2 position = new Vector2(scaleX * i, scaleY * j);
                            uv.Add(position);
                        }
                    }
                }
            }
        }
        Mesh returnvalue= MeshGenerator.GetCubes(positions, ignoreFace, Vector3.one);
        returnvalue.uv = uv.ToArray();
        return returnvalue;
    }


    /// <summary>
    /// Generating a mesh interpreting the 3D data as noise and generating cubes in a 3D grid if the noise is over the threshold
    /// Smoothens the mesh by reusing vertices
    /// </summary>
    /// <param name="data3D">The 3D data representation of the image (or of anything else if you want).</param>
    /// <param name="threshold">Value between 0 and 1. A good value here is normally 0.5 Different values can be appropriate for different (non image) data.</param>
    /// <param name="alwaysDrawBottomCube">With this parameter set the lowest place of cubes is always drawn. Making sure there are no "holes"</param>
    /// <returns></returns>
    public static Mesh Generate3DNoiseSmooth(Data3D data3D, float threshold, bool alwaysDrawBottomCube = true) {
        Vector3 StartPos = new Vector3(-0.5f * data3D.X + 0.5f, 0.5f, -0.5f * data3D.Y + 0.5f);
        if (alwaysDrawBottomCube) {
            StartPos = new Vector3(-0.5f * data3D.X + 0.5f, -0.5f, -0.5f * data3D.Y + 0.5f);
        }
        Vector3 spawnPosition;

        // move this much
        Vector2 minUV = new Vector2(0.5f * data3D.X, 0.5f * data3D.Y);
        //divide by this much
        Vector2 maxUV = new Vector2( data3D.X + 1,  data3D.Y + 1);



        List<Vector3> positions = new List<Vector3>();
        List<bool[]> ignoreFace = new List<bool[]>();
        List<Vector2> uv = new List<Vector2>();

        float scaleX = 1.0f / data3D.X;
        float scaleY = 1.0f / data3D.Y;
        float scaleZ = 1.0f / data3D.Z;

        for (int i = 0; i < data3D.X; i++) {
            for (int j = 0; j < data3D.Y; j++) {
                for (int k = 0; k < data3D.Z; k++) {


                    if (data3D[i, j, k].Value > threshold) {
                        spawnPosition = StartPos + new Vector3(i, k, j);
                        positions.Add(spawnPosition);
                        bool[] ignore = new bool[6] {
                            j>0 && data3D[i,j-1,k].Value>threshold,
                            j<data3D.Y-1 && data3D[i,j+1,k].Value>threshold,
                            k<data3D.Z-1 && data3D[i,j,k+1].Value>threshold,
                            i<data3D.X-1 && data3D[i+1,j,k].Value>threshold,
                            (k==0) || data3D[i,j,k-1].Value>threshold,
                            i>0 && data3D[i-1,j,k].Value>threshold,

                        };

                        ignoreFace.Add(ignore);
                        /*
                        int siteCount = 0;
                        for (int count2 = 0; count2 < 6; count2++) {
                            if (!ignore[count2]) {
                                siteCount++;
                            }
                        }
                        int endcount = siteCount * 4;
                        //Todo make option for flowing colors
                        for (int count = 0; count < endcount; count++) {
                            Vector2 position = new Vector2(scaleX * i, scaleY * j);
                            uv.Add(position);
                        }
                        */
                    }
                }
            }
        }
        Mesh returnvalue = MeshGenerator.GetCubesSmooth(positions, ignoreFace, Vector3.one, minUV, maxUV);
        //returnvalue.uv = uv.ToArray();
        return returnvalue;
    }



    /// <summary>
    /// Generates a Terrain (deformed plane) according to the 2D data
    /// </summary>
    /// <param name="data2D">The height data representation of the image</param>
    /// <param name="maxHeight">The maximum height the terrain should have </param>
    /// <returns>Returns a mesh representing the generated terrain.</returns>
    public static Mesh GenerateTerrain(DataGrid data2D, float maxHeight, bool removeBottom=false) {
        return MeshGenerator.ConstructGrid(data2D, maxHeight, 1, 1,  removeBottom);
    }

    /// <summary>
    /// Generate a mesh using a (simple) Marching Cubes algorithm. 
    /// </summary>
    /// <param name="data3D">The 3D data representation of the image (or of anything else if you want).</param>
    /// <param name="threshold">Value between 0 and 1. A good value here is normally 0.5 Different values will create (in average) more steap or less cheap angles.</param>
    /// <param name="maxHeight">The maximum height the mesh will have</param>
    /// <param name="alwaysDrawBottomCube">With this parameter set the lowest place of cubes is always drawn. Making sure there are no "holes"</param>
    /// <returns>Returns a mesh being made with marching cubes representing the image.</returns>
    public static Mesh GenerateMarshingCubes(Data3D data3D, float threshold, float maxHeight, bool alwaysDrawBottomCube = true) {
        float starty = 0.5f * maxHeight + 1;
        if (alwaysDrawBottomCube) {
            starty = starty - 0.5f;
        }
        return MeshGenerator.ConstructMarchingCubesYZSwitched(data3D, new Vector3(0, starty, 0), threshold);
    }

    /// <summary>
    /// Generate a mesh using an advanced Marching Cubes algorithm, allowing for different angels.
    /// </summary>
    /// <param name="data3D">The 3D data representation of the image (or of anything else if you want).</param>
    /// <param name="threshold">Value between 0 and 1. A good value here is normally 0.5 Different values will create (in average) more steap or less cheap angles.</param>
    /// <param name="maxHeight">The maximum height the mesh will have</param>
    /// <param name="alwaysDrawBottomCube">With this parameter set the lowest place of cubes is always drawn. Making sure there are no "holes"</param>
    /// <returns>Returns a mesh being made with the advanced marching cubes representing the image.</returns>

    public static Mesh GenerateMarshingCubesAdvanced(Data3D data3D, float threshold, float maxHeight, bool alwaysDrawBottomCube = true) {
        float starty = 0.5f * maxHeight + 1;
        if (alwaysDrawBottomCube) {
            starty = starty - 0.5f;
        }
        return MeshGenerator.ConstructMarchingCubesYZSwitched(data3D, new Vector3(0, starty, 0), Color.white, threshold);
    }





    /// <summary>
    /// Generate a SMOOTH mesh using a (simple) Marching Cubes algorithm. 
    /// </summary>
    /// <param name="data3D">The 3D data representation of the image (or of anything else if you want).</param>
    /// <param name="threshold">Value between 0 and 1. A good value here is normally 0.5 Different values will create (in average) more steap or less cheap angles.</param>
    /// <param name="maxHeight">The maximum height the mesh will have</param>
    /// <param name="alwaysDrawBottomCube">With this parameter set the lowest place of cubes is always drawn. Making sure there are no "holes"</param>
    /// <returns>Returns a mesh being made with marching cubes representing the image.</returns>
    public static Mesh GenerateMarshingCubesSmooth(Data3D data3D, float threshold, float maxHeight, bool alwaysDrawBottomCube = true) {
        float starty = 0.5f * maxHeight + 1;
        if (alwaysDrawBottomCube) {
            starty = starty - 0.5f;
        }
        return MeshGenerator.ConstructMarchingCubesYZSwitchedSmooth(data3D, new Vector3(0, starty, 0), threshold);
    }


    /// <summary>
    /// Generate a SMOOTH mesh using an advanced Marching Cubes algorithm, allowing for different angels.
    /// </summary>
    /// <param name="data3D">The 3D data representation of the image (or of anything else if you want).</param>
    /// <param name="threshold">Value between 0 and 1. A good value here is normally 0.5 Different values will create (in average) more steap or less cheap angles.</param>
    /// <param name="maxHeight">The maximum height the mesh will have</param>
    /// <param name="alwaysDrawBottomCube">With this parameter set the lowest place of cubes is always drawn. Making sure there are no "holes"</param>
    /// <returns>Returns a mesh being made with the advanced marching cubes representing the image.</returns>

    public static Mesh GenerateMarshingCubesAdvancedSmooth(Data3D data3D, float threshold, float maxHeight, bool alwaysDrawBottomCube = true) {
        float starty = 0.5f * maxHeight + 1;
        if (alwaysDrawBottomCube) {
            starty = starty - 0.5f;
        }
        return MeshGenerator.ConstructMarchingCubesYZSwitchedSmooth(data3D, new Vector3(0, starty, 0), Color.white, threshold);
    }


    /// <summary>
    /// Generates a save path for the mesh to be saved to. Is used since creating assets is only allowed in editor scripts.
    /// </summary>
    /// <returns></returns>
    public string GenerateSavePath() {
        string filepath = Path.Combine(path, MeshName + ".Asset");
        return filepath;
    }

    /// <summary>
    /// Colors the mesh. (Setting the color parameters) according to the chosen parameters (Heighgradient, Colorscaling and ColorOffset).
    /// </summary>
    public void ColorMesh() {

        switch (ColoringMethod) {
            case MaterialType.ColoredByHeight:
                TargetMesh.GetComponent<MeshRenderer>().sharedMaterial.shader = Shader.Find("Custom/SurfaceVertColor");
                break;
            case MaterialType.ColorTexture:
                TargetMesh.GetComponent<MeshRenderer>().sharedMaterial.shader = Shader.Find("Custom/SurfaceTexture");
                break;
            case MaterialType.ColorTextureAndHeight:
                TargetMesh.GetComponent<MeshRenderer>().sharedMaterial.shader = Shader.Find("Custom/SurfaceMixed");
                break;
            case MaterialType.ColorByHeightTransparent:
                TargetMesh.GetComponent<MeshRenderer>().sharedMaterial.shader = Shader.Find("Custom/SurfaceVertColorTransparent");
                break;
            case MaterialType.ColorTextureTransparent:
                TargetMesh.GetComponent<MeshRenderer>().sharedMaterial.shader = Shader.Find("Custom/SurfaceTextureTransparent");
                break;
            case MaterialType.ColorTextureAndHeightTransparent:
                TargetMesh.GetComponent<MeshRenderer>().sharedMaterial.shader = Shader.Find("Custom/SurfaceMixedTransparent");
                break;
            default:
                break;
        }



        if (GeneratedMesh == null) {
            Debug.LogWarning("There is no mesh generated. Generating mesh.");
            GenerateMesh(false);
        }


        //if (ColoringMethod == MaterialType.ColorTexture) {
            //return;
        //}

        Vector3[] vertices = GeneratedMesh.vertices;

        int vertexCount = vertices.Length;

        Color[] colors = new Color[vertexCount];
        Color endColor;
        for (int i = 0; i < vertexCount; i++) {
            if (!MixGradiants) {
                endColor= HeighGradient.Evaluate((vertices[i].y / MaxHeight) * ColorScaling + ColorOffset);
                //endColor.a = colors[i].a;
                colors[i] = endColor;
            } else {
                Color color1 = HeighGradient.Evaluate((vertices[i].y / MaxHeight) * ColorScaling + ColorOffset);
                Color color2 = HeighGradient2.Evaluate((vertices[i].y / MaxHeight) * ColorScaling + ColorOffset);

                endColor = Color.Lerp(color1, color2, GradientMixvalue); ;
                //endColor.a = colors[i].a;
                colors[i] = endColor;
            }
        }

        
        GeneratedMesh.colors = colors;
    }




    public void ResetView() {
        Lightning.transform.parent = this.transform;
        MainCamera.transform.parent = this.transform;

        this.transform.rotation = Quaternion.Euler(Vector3.zero);
        this.transform.position = Vector3.zero;

        Lightning.transform.parent = null;
        MainCamera.transform.parent = null;
    }

    public void PrepareMerge() {
        int multiplicator = 256; //2^8
        Lightning.transform.parent = this.transform;
        int layer= (int)Mathf.Pow(2,(int)ObjectNumber);
        layer = layer * multiplicator;
        this.gameObject.layer = (int)ObjectNumber+8;
        TargetMesh.gameObject.layer = this.gameObject.layer;
        Lightning.SetLayer(layer);
    }

    /// <summary>
    /// Saving the settings to the selected settings file (profile)
    /// </summary>
    public void SaveSettings() {
        if (UsedProfile.Locked) {
            Debug.LogWarning("Cant overwrite locked file");
            return;
        }

        UsedProfile.Texture = TextureToBlur;

        UsedProfile.MaxHeight = MaxHeight;
        UsedProfile.Invert = Invert;
        UsedProfile.Threshold = Threshold;
        UsedProfile.HeighGradient = HeighGradient;
        UsedProfile.AlwaysDrawBottomCube = RemoveBottomRow;
        UsedProfile.ColorTranslation = ColorOffset;
        UsedProfile.ColorScaling = ColorScaling;
        UsedProfile.VisualisationMethod = VisualisationMethod;
        UsedProfile.BlurRotation = BlurRotation;

        UsedProfile.CameraPosition = Lightning.MainCamera.transform.position;
        UsedProfile.CameraRotation = Lightning.MainCamera.transform.rotation;


        UsedProfile.SunPosition = Lightning.MainLight.transform.position;
        UsedProfile.SunRotation = Lightning.MainLight.transform.rotation;
        UsedProfile.SunColor = Lightning.MainLight.color;
        UsedProfile.SunIntensity = Lightning.MainLight.intensity;


        UsedProfile.Light1Position = Lightning.Spotlight1.transform.position;
        UsedProfile.Light1Rotation = Lightning.Spotlight1.transform.rotation;
        UsedProfile.Light1Color = Lightning.Spotlight1.color;
        UsedProfile.Light1Intensity = Lightning.Spotlight1.intensity;
        UsedProfile.Light1Range = Lightning.Spotlight1.range;
        UsedProfile.Light1Type = Lightning.Spotlight1.type;

        UsedProfile.Light2Position = Lightning.Spotlight2.transform.position;
        UsedProfile.Light2Rotation = Lightning.Spotlight2.transform.rotation;
        UsedProfile.Light2Color = Lightning.Spotlight2.color;
        UsedProfile.Light2Intensity = Lightning.Spotlight2.intensity;
        UsedProfile.Light2Range = Lightning.Spotlight2.range;
        UsedProfile.Light2Type = Lightning.Spotlight2.type;

        UsedProfile.Light3Position = Lightning.Spotlight3.transform.position;
        UsedProfile.Light3Rotation = Lightning.Spotlight3.transform.rotation;
        UsedProfile.Light3Color = Lightning.Spotlight3.color;
        UsedProfile.Light3Intensity = Lightning.Spotlight3.intensity;
        UsedProfile.Light3Range = Lightning.Spotlight3.range;
        UsedProfile.Light3Type = Lightning.Spotlight3.type;


    }

    /// <summary>
    /// Loading the settings from a settings file (profile)
    /// </summary>
    public void LoadSettings() {

        if (UsedProfile.Texture!=null) {
            TextureToBlur = UsedProfile.Texture;
        }


        MaxHeight = UsedProfile.MaxHeight;
        Invert = UsedProfile.Invert;
        Threshold = UsedProfile.Threshold;
        HeighGradient = UsedProfile.HeighGradient;
        RemoveBottomRow = UsedProfile.AlwaysDrawBottomCube;
        ColorOffset = UsedProfile.ColorTranslation;
        ColorScaling = UsedProfile.ColorScaling;
        VisualisationMethod = UsedProfile.VisualisationMethod;
        BlurRotation = UsedProfile.BlurRotation;


        Lightning.MainCamera.transform.position = UsedProfile.CameraPosition;
        Lightning.MainCamera.transform.rotation = UsedProfile.CameraRotation;


        Lightning.MainLight.transform.position = UsedProfile.SunPosition;
        Lightning.MainLight.transform.rotation = UsedProfile.SunRotation;
        Lightning.MainLight.color = UsedProfile.SunColor;
        Lightning.MainLight.intensity = UsedProfile.SunIntensity;


        Lightning.Spotlight1.transform.position = UsedProfile.Light1Position;
        Lightning.Spotlight1.transform.rotation = UsedProfile.Light1Rotation;
        Lightning.Spotlight1.color = UsedProfile.Light1Color;
        Lightning.Spotlight1.intensity = UsedProfile.Light1Intensity;
        Lightning.Spotlight1.range = UsedProfile.Light1Range;
        Lightning.Spotlight1.type = UsedProfile.Light1Type;

        Lightning.Spotlight2.transform.position = UsedProfile.Light2Position;
        Lightning.Spotlight2.transform.rotation = UsedProfile.Light2Rotation;
        Lightning.Spotlight2.color = UsedProfile.Light2Color;
        Lightning.Spotlight2.intensity = UsedProfile.Light2Intensity;
        Lightning.Spotlight2.range = UsedProfile.Light2Range;
        Lightning.Spotlight2.type = UsedProfile.Light2Type;

        Lightning.Spotlight3.transform.position = UsedProfile.Light3Position;
        Lightning.Spotlight3.transform.rotation = UsedProfile.Light3Rotation;
        Lightning.Spotlight3.color = UsedProfile.Light3Color;
        Lightning.Spotlight3.intensity = UsedProfile.Light3Intensity;
        Lightning.Spotlight3.range = UsedProfile.Light3Range;
        Lightning.Spotlight3.type = UsedProfile.Light3Type;
    }


    public void ExportSettingsFile() {
        if (Application.isPlaying) {
            FileBrowser.ShowSaveDialog(safeFile, onCancel);
        } else {
            safeFile(Path.Combine(Application.dataPath, JsonFileName));
        }
    }

    void safeFile(string[] files) {
        safeFile(files[0]);
    }

    void safeFile(string file) {
        SaveSettings();

        MeshCreationExportSettings export = new MeshCreationExportSettings();
        export.AlwaysDrawBottomCube = RemoveBottomRow;
        export.BlurRotation = BlurRotation;
        export.ColorScaling = ColorScaling;
        export.ColorTranslation = ColorOffset;
        export.HeighGradient = HeighGradient;
        export.Invert = Invert;
        export.MaxHeight = MaxHeight;
        export.Threshold = Threshold;
        export.VisualisationMethod = VisualisationMethod;


        string json = JsonUtility.ToJson(export);
        string path = file;
        File.WriteAllText(path + ".json", json);
    }

    //Needed for file browser
    void onCancel() {
        Debug.Log("Request got cancelled");
    }



    public void ImportSettingsFile() {
        if (Application.isPlaying) {
            FileBrowser.SetFilters(false, ".json");
            FileBrowser.ShowLoadDialog(loadSettingsFromJson, onCancel, false, false, Application.dataPath);
        } else {
            loadSettingsFromJson(Path.Combine(Application.dataPath, JsonFileName + ".json"));
        }

    }

    void loadSettingsFromJson(string[] filePaths) {
        string file = filePaths[0];
        loadSettingsFromJson(file);
    }

    void loadSettingsFromJson(string file) {
        string json = File.ReadAllText(file);
        MeshCreationExportSettings export = JsonUtility.FromJson<MeshCreationExportSettings>(json);

        RemoveBottomRow = export.AlwaysDrawBottomCube;
        BlurRotation = export.BlurRotation;
        ColorScaling = export.ColorScaling;
        ColorOffset = export.ColorTranslation;
        HeighGradient = export.HeighGradient;
        Invert = export.Invert;
        MaxHeight = export.MaxHeight;
        Threshold = export.Threshold;
        VisualisationMethod = export.VisualisationMethod;

    }

    public void PrepareNewMaterial() {
        Material newMat = new Material(TargetMesh.GetComponent<MeshRenderer>().sharedMaterial.shader);
        newMat.name = "GeneratedTerrainMat";
        newMat.CopyPropertiesFromMaterial(TargetMesh.GetComponent<MeshRenderer>().sharedMaterial);
        TargetMesh.GetComponent<MeshRenderer>().sharedMaterial = newMat;
        this.GetComponent<MeshRenderer>().material = newMat;
    }

    /// <summary>
    /// Types an image can be visualised as terrain.
    /// </summary>
    public enum VisualitationType {
        Noise2D,
        Noise3D,
        Terrain,
        MarshingCubes,
        MarshingCubesAdvanced,
        SmoothNoise3D,
        SmoothMarshingCubes,
        SmoothMarshingCubesAdvanced
    }

    public enum MaterialType {
        ColoredByHeight,
        ColorTexture,
        ColorTextureAndHeight,
        ColorByHeightTransparent,
        ColorTextureTransparent,
        ColorTextureAndHeightTransparent

    }

    public enum LayerMask {
        Object1,
        Object2,
        Object3,
        Object4,
        Object5,
        Object6,
        Object7,
        Object8,
        Object9,
        Object10,
        Object11,
        Object12,
        Object13,
        Object14,
        Object15,
        Object16,
        Object17,
        Object18, 
        Object19,
        Object20,
    }
}
